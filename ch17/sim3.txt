Under the first-fit strategy, the free list evolves as follows:

    $ ./malloc.py -H 0 -n 10 -p FIRST -s 0
    seed 0
    size 100
    baseAddr 1000
    headerSize 0
    alignment -1
    policy FIRST
    listOrder ADDRSORT
    coalesce False
    numOps 10
    range 10
    percentAlloc 50
    allocList
    compute False
    [...]

    ptr[0] = Alloc(3) returned 1000
    List = [(1003, 97)]

    Free(ptr[0])
    returned 0
    List = [(1000, 3), (1003, 97)]

    ptr[1] = Alloc(5) returned 1003
    List = [(1000, 3), (1008, 92)]

    Free(ptr[1])
    returned 0
    List = [(1000, 3), (1003, 5), (1008, 92)]

    ptr[2] = Alloc(8) returned 1008
    List = [(1000, 3), (1003, 5), (1016, 84)]

    Free(ptr[2])
    returned 0
    List = [(1000, 3), (1003, 5), (1008, 8), (1016, 84)]

    ptr[3] = Alloc(8) returned 1008
    List = [(1000, 3), (1003, 5), (1016, 84)]

    Free(ptr[3])
    returned 0
    List = [(1000, 3), (1003, 5), (1008, 8), (1016, 84)]

    ptr[4] = Alloc(2) returned 1000
    List = [(1002, 1), (1003, 5), (1008, 8), (1016, 84)]

    ptr[5] = Alloc(7) returned 1008
    List = [(1002, 1), (1003, 5), (1015, 1), (1016, 84)]

With the above calls, this appears identical to best-first, but the key
difference is that first-fit does not neet to search the entire free list for
an optimal block. This can lead to less efficient memory usage, however.
